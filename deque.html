<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="wid
    th=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>ds</title>
</head>

<body>
    <nav>
        <label class="logo">DS</label>
        <ul>
            <li><a class="active" href="index.html">Home</a></li>
            <li><a href="ds_introduction.html">About</a></li>
            <li><a href="https://youtu.be/R_iJzDBiK60">Dsc-coea</a></li>
            <li><a href="https://www.javatpoint.com/data-structure-tutorial">Notes</a></li>
        </ul>
        <label id="icon"></label>
        <i class="fas fa-bars"></i>
    </nav>
    <div id="contentwrapper">
        <div class="innertext">
        </div>
    </div>
    <div id="leftcolumn">
        <div class="innertext">
            <b>DS-TUTORIA</b><br>
            <a href="index.html">DS-TUTORIAL</a> <br>
            <a href="ds_introduction.html">DS Introduction</a><br>
            <a href="ds_algo.html">DS Algorithm</a><br>
            <a href="asympotic_analysis.html">Asymptotic Analysis</a><br>
            <a href="ds_Pointer.html">DS Pointer</a><br>
            <a href="ds_structure.html"> DS Structure</a><br>
            <b> DS Array</b><br>
            <a href="da_array.html"> DS Array</a><br>
            <a href="2d_array.html"> 2D Array </a><br>

            <b> DS Linked List</b><br>
            <a href="linked_list.html"> Linked List</a><br>
            <a href="singly-linkedlist.html"> Singly Linked List</a><br>
            <a href="double-linkedlist.html"> Doubly Linked List</a><br>
            <a href="circular-linked-list.html"> Circular Linked List</a><br>
            <a href="circular-doubly.html"> Circular Doubly List</a><br>
            <a href="skip-list.html"> Skip list in DS</a><br>
            <b>DS Stack</b><br>
            <a href="stack.html"> DS Stack</a><br>
            <a href="stack.html"> Array Implementation</a><br>
            <a href="linked-list-impl.html"> Linked List Implementation</a><br>
            <b>DS Queue</b><br>

            <a href="ds-queue.html"> DS Queue</a><br>
            <a href="ds-queue.html"> Types of Queues</a><br>
            <a href="linked-list-repre-queue.html"> Array Representation</a><br>
            <a href="linked-list-repre-queue.html"> Linked List Representation</a><br>
            <a href="circular-q-dueue.html"> Circular Queue</a><br>
            <a href="deque.html"> Deque</a><br>
            <a href="deque.html"> Priority Queue</a><br>
        </div>
    </div>
    <div id="contentcolumn">
        <div id="rightcolumn">
            <div class="innertext">
                <h2>Deque</h2>
                <br>
                <br>
                The dequeue stands for Double Ended Queue. In the queue, the insertion takes place from one end while
                the deletion takes place from another end. The end at which the insertion occurs is known as the rear
                end whereas the end at which the deletion occurs is known as front end.
                <br><br>
                <img src="ds-deque.png" width="500px" height="200px"><br><br>
                <b>Deque</b> is a linear data structure in which the insertion and deletion operations are performed
                from both ends. We can say that deque is a generalized version of the queue.
                <br>
                <b>Let's look at some properties of deque.</b>
                <br><br>
                Deque can be used both as <b>stack</b> and<b> queue</b> as it allows the insertion and deletion
                operations on both ends.
                <br><br>
                In deque, the insertion and deletion operation can be performed from one side. The stack follows the
                LIFO rule in which both the insertion and deletion can be performed only from one end; therefore, we
                conclude that deque can be considered as a stack.
                <br><br>
                <img src="ds-deque2.png" width="500px" height="200px"><br><br>

                In deque, the insertion can be performed on one end, and the deletion can be done on another end. The
                queue follows the FIFO rule in which the element is inserted on one end and deleted from another end.
                Therefore, we conclude that the deque can also be considered as the queue.
                <br><br>
                <img src="ds-deque3.png" width="500px" height="200px"><br><br>

                There are two types of Queues, <b>Input-restricted queue,</b> and<b>output-restricted queue.</b><br><br>

                <ul>
                    <li><b>1.Input-restricted queue: </b>The input-restricted queue means that some restrictions are
                        applied to the insertion. In input-restricted queue, the insertion is applied to one end while
                        the deletion is applied from both the ends.
                    </li><br>
                    <img src="ds-deque4.png" width="500px" height="200px"><br><br>
                    <li><b>2.Output-restricted queue:</b> The output-restricted queue means that some restrictions are
                        applied to the deletion operation. In an output-restricted queue, the deletion can be applied
                        only from one end, whereas the insertion is possible from both ends.
                    </li>
                    <img src="ds-deque5.png" width="500px" height="200px"><br><br>
                    <li><b></b></li>

                </ul>
                <br><br>
                <h2>Operations on Deque
                </h2><br><br>
                <b>The following are the operations applied on deque:</b><br><br>
                <ul>
                    <li>Insert at front </li><br>
                    <li>Delete from end
                    </li><br>
                    <li>insert at rear
                    </li><br>
                    <li>delete from rear
                    </li><br>
                </ul><br><br>
                <b>Other than insertion and deletion, we can also perform peek operation in deque. Through peek
                    operation, we can get the front and the rear element of the dequeue.
                </b><br><br>We can perform two more operations on dequeue:<br><br>
                <ul>
                    <li><b>isFull():</b> This function returns a true value if the stack is full; otherwise, it returns
                        a false value.
                    </li>
                    <li><b>isEmpty(): </b>This function returns a true value if the stack is empty; otherwise it returns
                        a false value.
                    </li>
                </ul><br><br>
                <h3>Memory Representation
                </h3><br><br>
                The deque can be implemented using two data structures, i.e., circular array, and doubly linked list. To
                implement the deque using circular array, we first should know what is circular array.
                <br><br>
                <h2>What is a circular array?
                </h2><br><br>
                An array is said to be circular if the last element of the array is connected to the first element of
                the array. Suppose the size of the array is 4, and the array is full but the first location of the array
                is empty. If we want to insert the array element, it will not show any overflow condition as the last
                element is connected to the first element. The value which we want to insert will be added in the first
                location of the array.
                <br><br>
                <img src="ds-deque6.png" width="400px" height="300px"><br><br>
                <h2>Applications of Deque
                </h2><br><br>
                <ul>
                    <li>ThIt can be used as a palindrome checker means that if we read the string from both ends, then
                        the string would be the same.
                    </li><br>
                    <li>It can be used as a palindrome checker means that if we read the string from both ends, then the
                        string would be the same.
                    </li><br>
                    <li>It can be used for multiprocessor scheduling. Suppose we have two processors, and each processor
                        has one process to execute. Each processor is assigned with a process or a job, and each process
                        contains multiple threads. Each processor maintains a deque that contains threads that are ready
                        to execute. The processor executes a process, and if a process creates a child process then that
                        process will be inserted at the front of the deque of the parent process. Suppose the processor
                        P2 has completed the execution of all its threads then it steals the thread from the rear end of
                        the processor P1 and adds to the front end of the processor P2. The processor P2 will take the
                        thread from the front end; therefore, the deletion takes from both the ends, i.e., front and
                        rear end. This is known as the A-steal algorithm for scheduling.
                    </li><br>
                </ul>
                <br><br>
                <h2>Implementation of Deque using a circular array
                </h2><br><br>
                <h3>The following are the steps to perform the operations on the Deque:</h3><br><br>
                <h2>Enqueue operation</h2><br><br>
                <ul>
                    <li>1.Initially, we are considering that the deque is empty, so both front and rear are set to -1,
                        i.e., f = -1 and r = -1.
                    </li><br>
                    <li>2.As the deque is empty, so inserting an element either from the front or rear end would be the
                        same thing. Suppose we have inserted element 1, then front is equal to 0, and the rear is also
                        equal to 0.
                    </li><br>
                    <img src="ds-deque7.png" width="500px" height="200px"><br><br>

                    <li>3.Suppose we want to insert the next element from the rear. To insert the element from the rear
                        end, we first need to increment the rear, i.e., rear=rear+1. Now, the rear is pointing to the
                        second element, and the front is pointing to the first element.
                    </li><br>
                    <img src="ds-deque8.png" width="500px" height="200px"><br><br>
                    <li>4.Suppose we are again inserting the element from the rear end. To insert the element, we will
                        first increment the rear, and now rear points to the third element.
                    </li><br>
                    <img src="ds-deque9.png" width="500px" height="200px"><br><br>

                    <li>5.If we want to insert the element from the front end, and insert an element from the front, we
                        have to decrement the value of front by 1. If we decrement the front by 1, then the front points
                        to -1 location, which is not any valid location in an array. So, we set the front as (n -1),
                        which is equal to 4 as n is 5. Once the front is set, we will insert the value as shown in the
                        below figure:
                    </li><br>
                    <img src="ds-deque10.png" width="500px" height="200px"><br><br>

                </ul>
                <br><br>
                <h2>Dequeue Operation</h2>
                <br><br>
                <ul>
                    <li>1.If the front is pointing to the last element of the array, and we want to perform the delete
                        operation from the front. To delete any element from the front, we need to set front=front+1.
                        Currently, the value of the front is equal to 4, and if we increment the value of front, it
                        becomes 5 which is not a valid index. Therefore, we conclude that if front points to the last
                        element, then front is set to 0 in case of delete operation.
                    </li><br>
                    <img src="ds-deque11.png" width="500px" height="400px"><br><br>

                    <li>2.If we want to delete the element from rear end then we need to decrement the rear value by 1,
                        i.e., rear=rear-1 as shown in the below figure:
                    </li><br>
                    <img src="ds-deque12.png" width="500px" height="400px"><br><br>
                    <li>3.If the rear is pointing to the first element, and we want to delete the element from the rear
                        end then we have to set rear=n-1 where n is the size of the array as shown in the below figure:

                    </li>
                    <img src="ds-deque13.png" width="500px" height="400px"><br><br>
                </ul>
                <br>
                <br>
                <h2>What is a priority queue?
                </h2><br><br>
                A priority queue is an abstract data type that behaves similarly to the normal queue except that each
                element has some priority, i.e., the element with the highest priority would come first in a priority
                queue. The priority of the elements in a priority queue will determine the order in which elements are
                removed from the priority queue.
                <br>
                The priority queue supports only comparable elements, which means that the elements are either arranged
                in an ascending or descending order.
                <br>
                For example, suppose we have some values like 1, 3, 4, 8, 14, 22 inserted in a priority queue with an
                ordering imposed on the values is from least to the greatest. Therefore, the 1 number would be having
                the highest priority while 22 will be having the lowest priority.
                <br>
                <h2>Characteristics of a Priority queue
                </h2><br><br>
                <ul>
                    <li>Every element in a priority queue has some priority associated with it.
                    </li><br>
                    <li>An element with the higher priority will be deleted before the deletion of the lesser priority.
                    </li><br>
                    <li>If two elements in a priority queue have the same priority, they will be arranged using the FIFO
                        principle.
                    </li><br>
                </ul>
                <br><br>
                <h2>Types of Priority Queue
                </h2><br>
                <ul>
                    <li><b>Ascending order priority queue:</b> In ascending order priority queue, a lower priority
                        number is given as a higher priority in a priority. For example, we take the numbers from 1 to 5
                        arranged in an ascending order like 1,2,3,4,5; therefore, the smallest number, i.e., 1 is given
                        as the highest priority in a priority queue.
                    </li><br>
                    <img src="ds-priority-queue.png" width="600px" height="300px"><br><br>

                    <li><b>Descending order priority queue: </b>In descending order priority queue, a higher priority
                        number is given as a higher priority in a priority. For example, we take the numbers from 1 to 5
                        arranged in descending order like 5, 4, 3, 2, 1; therefore, the largest number, i.e., 5 is given
                        as the highest priority in a priority queue.
                    </li><br>
                    <img src="ds-priority-queue2.png" width="600px" height="300px"><br><br>

                </ul>
                <br>
                <br>
                <h2>Representation of priority queue
                </h2><br><br>
                Now, we will see how to represent the priority queue through a one-way list.
                <br>
                We will create the priority queue by using the list given below in which INFO list contains the data
                elements, PRN list contains the priority numbers of each data element available in the INFO list, and
                LINK basically contains the address of the next node.
                <br>
                <img src="ds-priority-queue3.png" width="600px" height="300px"><br><br>
                <h3>Let's create the priority queue step by step.</h3><br>
                <br>
                In the case of priority queue, lower priority number is considered the higher priority, i.e., lower
                priority number = higher priority.
                <br>
                <b>Step 1: </b>In the list, lower priority number is 1, whose data value is 333, so it will be inserted
                in the list as shown in the below diagram:
                <br><br>
                <b>Step 2:</b> After inserting 333, priority number 2 is having a higher priority, and data values
                associated with this priority are 222 and 111. So, this data will be inserted based on the FIFO
                principle; therefore 222 will be added first and then 111.
                <br><br>
                <b>Step 3: </b>After inserting the elements of priority 2, the next higher priority number is 4 and data
                elements associated with 4 priority numbers are 444, 555, 777. In this case, elements would be inserted
                based on the FIFO principle; therefore, 444 will be added first, then 555, and then 777.
                <br><br>
                <b>Step 4: </b>After inserting the elements of priority 4, the next higher priority number is 5, and the
                value associated with priority 5 is 666, so it will be inserted at the end of the queue.
                <br><br>
                <img src="ds-priority-queue4.png" width="800px" height="350px"><br><br>



                <h2>Implementation of Priority Queue
                </h2><br><br>
                The priority queue can be implemented in four ways that include arrays, linked list, heap data structure
                and binary search tree. The heap data structure is the most efficient way of implementing the priority
                queue, so we will implement the priority queue using a heap data structure in this topic. Now, first we
                understand the reason why heap is the most efficient way among all the other data structures.
                <br><br>
                <h3>Analysis of complexities using different implementations

                </h3><br><br>
                <table>
                    <tr>
                        <td>Implementation</td>
                        <td>add</td>
                        <td>Remove</td>
                        <td>peek</td>
                    </tr>
                    <tr>
                        <td>Linked list</td>
                        <td>O(1)</td>
                        <td>O(n)</td>
                        <td> O(n)</td>
                    </tr>
                    <tr>
                        <td>Binary heap </td>
                        <td>O(logn) </td>
                        <td>O(logn) </td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>Binary search tree </td>
                        <td>O(logn) </td>
                        <td>O(logn)</td>
                        <td>O(1)
                        </td>
                    </tr>
                </table>
                <br><br>
                <h2>What is Heap?
                </h2><br><br>
                A heap is a tree-based data structure that forms a complete binary tree, and satisfies the heap
                property. If A is a parent node of B, then A is ordered with respect to the node B for all nodes A and B
                in a heap. It means that the value of the parent node could be more than or equal to the value of the
                child node, or the value of the parent node could be less than or equal to the value of the child node.
                Therefore, we can say that there are two types of heaps:
                <br><br>
                <b>Max heap: </b>The max heap is a heap in which the value of the parent node is greater than the value
                of the child nodes.
                <br>
                <img src="ds-priority-queue5.png" width="600" height="400"><br><br>
                <b>Min heap: </b>The min heap is a heap in which the value of the parent node is less than the value of
                the child nodes.
                <br><img src="ds-priority-queue6.png" width="600" height="400"><br><br>




                <button class="button button" >
                    <a href="https://www.javatpoint.com/ds-priority-queue">Read More</a>




            </div>
            <button class="button button2">
                <a href="circular-q-dueue.html">PREV</a></button>
         


        </div>
    </div>

    <footer>
        <div id="footer">
            <div class="inner-footer">
                <div class="footer-items">
                    <h3>About DSC</h3>
                    <p>codesyouth is platform used for Multinational company recruitment process and
                        brief history about that and also about<br>seminar topic for computer science
                        student.Codesyouth is a project developing<br>under Developer student club.</p>
                </div>
                <div class="footer-items">
                    <h3>NOTS</h3>
                    <div class="border"></div>
                    <ul>
                        <a href="https://www.javatpoint.com/html-tutorial">HTML</a>
                        <br>
                        <a href="https://www.javatpoint.com/python-tutorial">PYTHON</a>
                        <br>
                        <a href="https://www.javatpoint.com/java-tutorial">java</a>
                        <br>
                        <a href="https://www.javatpoint.com/c-programming-language-tutorial">c language</a>
                        <br>
                        <a href="https://www.javatpoint.com/cpp-tutorial">C++</a>
                        <br>
                        <a href="https://www.javatpoint.com/c-sharp-tutorial">C#</a>
                    </ul>
                </div>
                <div class="footer-items">
                    <h3>Contact Us</h3>
                    <div class="border"></div>
                    <a href="https://www.facebook.com/javatpoint">
                        <li><i class="fa fa-facebook" aria-hidden="true"></i></li>
                        <img src="facebook.png" width="35px" height="35px">
                    </a>
                    <a href="https://www.javatpoint.com/instagram-algorithm">
                        <li><i class="fa fa-instagram" aria-hidden="true"></i></li>
                        <img src="instagram.webp" width="35px" height="35px">
                    </a>
                    <a href="https://twitter.com/pagejavatpoint">
                        <li><i class="fa fa-twitter" aria-hidden="true"></i></li>
                        <img src="twitter.png" width="35px" height="35px">
                    </a>

                    <a href="https://www.youtube.com/channel/UCUnYvQVCrJoFWZhKK3O2xLg">
                        <li><i class="fa fa-youtube" aria-hidden="true"></i></li>
                        <img src="youtube.png" width="35px" height="35px">
                    </a>
                </div>
            </div>
        </div>
        <div class="footer-bottom">
            Copyright@codesyouth 2020. All rights reserved.
        </div>


    </footer>
</body>

</html>
