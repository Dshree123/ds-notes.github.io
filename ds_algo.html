<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="wid
    th=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>ds</title>
</head>

<body>
    <nav>
        <label class="logo">DS</label>
        <ul>
            <li><a class="active" href="#">Home</a></li>
            <li><a href="#">About</a></li>
            <li><a href="https://youtu.be/R_iJzDBiK60">Dsc-coea</a></li>
            <li><a href="#">Notes</a></li>
        </ul>
        <label id="icon"></label>
        <i class="fas fa-bars"></i>
    </nav>
    <div id="contentwrapper">
        <div class="innertext">
  </div>
    </div>
    <div id="leftcolumn">
        <div class="innertext">
            <b>DS-TUTORIA</b><br>
            <a href="index.html">DS-TUTORIAL</a> <br>
            <a href="ds_introduction.html">DS Introduction</a><br>
            <a href="ds_algo.html">DS Algorithm</a><br>
            <a href="asympotic_analysis.html">Asymptotic Analysis</a><br>
            <a href="ds_Pointer.html">DS Pointer</a><br>
            <a href="ds_structure.html"> DS Structure</a><br>
            <b> DS Array</b><br>
            <a href="da_array.html"> DS Array</a><br>
            <a href="2d_array.html"> 2D Array </a><br>
            <b> DS Linked List</b><br>
            <a href="linked_list.html"> Linked List</a><br>
            
            <a href="singly-linkedlist.html"> Singly Linked List</a><br>
            <a href="double-linkedlist.html"> Doubly Linked List</a><br>
            <a href="circular-linked-list.html"> Circular Linked List</a><br>
            <a href="circular-doubly.html"> Circular Doubly List</a><br>
            <a href="skip-list.html"> Skip list in DS</a><br>
            <b>DS Stack</b><br>
            <a href="stack.html"> DS Stack</a><br>
            <a href="stack.html"> Array Implementation</a><br>
            <a href="linked-list-impl.html"> Linked List Implementation</a><br>
            <b>DS Queue</b><br>
            <a href="ds-queue.html"> DS Queue</a><br>
            <a href="ds-queue.html"> Types of Queues</a><br>
            <a href="linked-list-repre-queue.html"> Array Representation</a><br>
            <a href="linked-list-repre-queue.html"> Linked List Representation</a><br>
            <a href="circular-q-dueue.html"> Circular Queue</a><br>
            <a href=""> Deque</a><br>
            <a href=""> Priority Queue</a><br>
        </div>
    </div>
        <div id="contentcolumn">
            <div id="rightcolumn">
            <div class="innertext">
                <h2>DS Algorithm</h2><br><br>
                <h2> What is an Algorithm?</h2><br><br>
                An algorithm is a process or a set of rules required to perform calculations or some other
                problem-solving operations especially by a computer. The formal definition of an algorithm is that it
                contains the finite set of instructions which are being carried in a specific order to perform the
                specific task. It is not the complete program or code; it is just a solution (logic) of a problem, which
                can be represented either as an informal description using a Flowchart or Pseudocode.
                <br><br>
                <h2>Characteristics of an Algorithm
                </h2><br><br><b>The following are the characteristics of an algorithm:</b><br><br>
                <ul>
                    <li><b>Input:</b> An algorithm has some input values. We can pass 0 or some input value to an
                        algorithm.</li><br><br>
                    <li><b>Output:</b> We will get 1 or more output at the end of an algorithm.</li><br><br>
                    <li><b>Unambiguity:</b> An algorithm should be unambiguous which means that the instructions in an
                        algorithm should be clear and simple.</li>
                    <br<br>
                        <li><b>Finiteness:</b> An algorithm should have finiteness. Here, finiteness means that the
                            algorithm should contain a limited number of instructions, i.e., the instructions should be
                            countable.</li><br><br>
                        <li><b>Effectiveness:</b> An algorithm should be effective as each instruction in an algorithm
                            affects the overall process.</li><br><br>
                        <li><b>Language independent:</b> An algorithm must be language-independent so that the
                            instructions in an algorithm can be implemented in any of the languages with the same
                            output.</li><br><br>
                </ul> <br><br>
                <h2>Dataflow of an Algorithm
                </h2> <br><br>
                <ul>
                    <li><b> Problem: </b>A problem can be a real-world problem or any instance from the real-world
                        problem for which we need to create a program or the set of instructions. The set of
                        instructions is known as an algorithm.</li><br><br>
                    <li><b> Algorithm:</b> An algorithm will be designed for a problem which is a step by step
                        procedure.</li><br><br>
                    <li><b>Input: After designing an algorithm, the required and the desired inputs are provided to the
                            algorithm.</b><br><br>
                    <li><b>Processing unit: </b>The input will be given to the processing unit, and the processing unit
                        will produce the desired output</li><br><br>
                    <li><b>Output: </b>The output is the outcome or the result of the program.</li><br><br>
                </ul><br><br>
                <h2>Approaches of Algorithm
                </h2><br><br>
                <b>The following are the approaches used after considering both the theoretical and practical importance
                    of designing an algorithm:
                </b><br><br>
                <ul style="list-style-type:disc">
                    <li><b>Brute force algorithm:</b> The general logic structure is applied to design an algorithm. It
                        is also known as an exhaustive search algorithm that searches all the possibilities to provide
                        the required solution. Such algorithms are of two types:</li><br>
                    <ol>
                        <li><b>1.Optimizing: </b>Finding all the solutions of a problem and then take out the best
                            solution or if the value of the best solution is known then it will terminate if the best
                            solution is known.
                        </li><br>
                        <li><b>2.Sacrificing:</b> As soon as the best solution is found, then it will stop.</li>
                    </ol>
                    <br>
                    <li><b>Divide and conquer:</b> It is a very implementation of an algorithm. It allows you to design
                        an algorithm in a step-by-step variation. It breaks down the algorithm to solve the problem in
                        different methods. It allows you to break down the problem into different methods, and valid
                        output is produced for the valid input. This valid output is passed to some other function.
                    </li><br>
                    <li><b>Greedy algorithm: </b>It is an algorithm paradigm that makes an optimal choice on each
                        iteration with the hope of getting the best solution. It is easy to implement and has a faster
                        execution time. But, there are very rare cases in which it provides the optimal solution.</li>
                    <br>
                    <li><b>Dynamic programming: </b>It makes the algorithm more efficient by storing the intermediate
                        results. It follows five different steps to find the optimal solution for the problem:
                    </li><br>
                    <ol>
                        <li>1.It breaks down the problem into a subproblem to find the optimal solution.</li><br>
                        <li>2. After breaking down the problem, it finds the optimal solution out of these subproblems.
                        </li><br>
                        <li> 3.Stores the result of the subproblems is known as memorization.</li><br>
                        <li>4.Reuse the result so that it cannot be recomputed for the same subproblems.</li><br>
                        <li> 5.Finally, it computes the result of the complex program.</li><br>
                    </ol>
                    <li><b>Branch and Bound Algorithm:</b> The branch and bound algorithm can be applied to only integer
                        programming problems. This approach divides all the sets of feasible solutions into smaller
                        subsets. These subsets are further evaluated to find the best solution.
                    </li><br>
                    <li><b>Randomized Algorithm: </b>As we have seen in a regular algorithm, we have predefined input
                        and required output. Those algorithms that have some defined set of inputs and required output,
                        and follow some described steps are known as deterministic algorithms. What happens that when
                        the random variable is introduced in the randomized algorithm?. In a randomized algorithm, some
                        random bits are introduced by the algorithm and added in the input to produce the output, which
                        is random in nature. Randomized algorithms are simpler and efficient than the deterministic
                        algorithm.
                    </li><br>
                    <li><b>Backtracking:</b> Backtracking is an algorithmic technique that solves the problem
                        recursively and removes the solution if it does not satisfy the constraints of a problem.
                    </li>

                </ul>
                <br>
                The major categories of algorithms are given below:<br>
                <br>
                <ul>
                    <li><b>Sort: </b>Algorithm developed for sorting the items in a certain order.</li><br>
                    <b> Search:</b> Algorithm developed for searching the items inside a data structure.</li><br><br>
                    <b> Delete:</b> Algorithm developed for deleting the existing element from the data structure.</li>
                    <br><br>

                    <b> Insert: </b>Algorithm developed for inserting an item inside a data structure.</li><br><br>
                    <b> Update: </b>Algorithm developed for updating the existing element inside a data structure.</li>
                    <br><br>
                </ul><br><br>
                <h2>Algorithm Complexity
                </h2><br><br>
                The performance of the algorithm can be measured in two factors:<br><br>
                <ul>
                    <li><b>1.Time complexity: </b>The time complexity of an algorithm is the amount of time required to
                        complete the execution. The time complexity of an algorithm is denoted by the big O notation.
                        Here, big O notation is the asymptotic notation to represent the time complexity. The time
                        complexity is mainly calculated by counting the number of steps to finish the execution. Let's
                        understand the time complexity through an example.
                    </li> <br><br>
                </ul>
                <div class="box">
                    sum=0; <br><br>
                    // Suppose we have to calculate the sum of n numbers. <br><br>
                    for i=1 to n <br><br>
                    sum=sum+i; <br><br>
                    // when the loop ends then sum holds the sum of the n numbers <br><br>
                    return sum; <br>
                </div><br>
                In the above code, the time complexity of the loop statement will be atleast n, and if the value of n
                increases, then the time complexity also increases. While the complexity of the code, i.e., return sum
                will be constant as its value is not dependent on the value of n and will provide the result in one step
                only. We generally consider the worst-time complexity as it is the maximum time taken for any given
                input size.
                <br><br>
                <ul>
                    <li><b>2.Space complexity: </b>An algorithm's space complexity is the amount of space required to
                        solve a problem and produce an output. Similar to the time complexity, space complexity is also
                        expressed in big O notation.
                    </li><br>
                </ul>
                For an algorithm, the space is required for the following purposes:<br><br>
                <ul>
                    <li>1.To store program instructions</li><br>
                    <li> 2.To store constant values</li><br>
                    <li> 3. To store variable values</li><br>
                    <li> 4.To track the function calls, jumping statements, etc.</li><br>
                </ul><br><br>
                <b>Auxiliary space:</b>The extra space required by the algorithm, excluding the input size, is known as
                an auxiliary space. The space complexity considers both the spaces, i.e., auxiliary space, and space
                used by the input.
                <br>
                So,
                <br>
                <div class="box">
                    <b>Space complexity = Auxiliary space + Input size.</b>
                </div><br>
                <h2>Types of Algorithms
                </h2><br><br>
                The following are the types of algorithm:<br><br>
                <ul>

                    <li><b>1.Search Algorithm</b></li><br>
                    <li><b>2.Sort Algorithm</b></li><br>
                </ul>
                <br>
                <h3>Search Algorithm</h3>
                <br>

                On each day, we search for something in our day to day life. Similarly, with the case of computer, huge
                data is stored in a computer that whenever the user asks for any data then the computer searches for
                that data in the memory and provides that data to the user. There are mainly two techniques available to
                search the data in an array:
                <br><br>
                <ul>
                    <li><b>a.Linear search </b></li><br>
                    <li><b>b.Binary Search </b></li><br>
                </ul><br>
                <h3>Linear Search</h3><br>
                Linear search is a very simple algorithm that starts searching for an element or a value from the
                beginning of an array until the required element is not found. It compares the element to be searched
                with all the elements in an array, if the match is found, then it returns the index of the element else
                it returns -1. This algorithm can be implemented on the unsorted list.
                <br><br>
                <h3>Binary Search</h3><br>
                A Binary algorithm is the simplest algorithm that searches the element very quickly. It is used to
                search the element from the sorted list. The elements must be stored in sequential order or the sorted
                manner to implement the binary algorithm. Binary search cannot be implemented if the elements are stored
                in a random manner. It is used to find the middle element of the list.
                <br><br>
                <h2>Sorting Algorithms</h2><br><br>
                Sorting algorithms are used to rearrange the elements in an array or a given data structure either in an
                ascending or descending order. The comparison operator decides the new order of the elements.
                <br><br>
                <h2>Why do we need a sorting algorithm?</h2><br><br>

                <ul>
                    <li>An efficient sorting algorithm is required for optimizing the efficiency of other algorithms
                        like binary search algorithm as a binary search algorithm requires an array to be sorted in a
                        particular order, mainly in ascending order.
                    </li><br>
                    <li>It produces information in a sorted order, which is a human-readable format.
                    </li><br>
                    <li>Searching a particular element in a sorted list is faster than the unsorted list.
                    </li><br>
                </ul>


            </div><br>

            <button class="button button2">
                <a href="ds_introduction.html">PREV</a></button>
            <button class=" button button1">
                    <a href="asympotic_analysis.html">NEXT</a></button>

        </div>
    </div>
      
<footer>
    <div id="footer">
        <div class="inner-footer">
            <div class="footer-items">
    <h3>About DSC</h3>
    <p>codesyouth is platform used for Multinational company recruitment process and
        brief history about that and also about<br>seminar topic for computer science
        student.Codesyouth is a project developing<br>under Developer student club.</p>
</div>
<div class="footer-items">
    <h3>NOTS</h3>
    <div class="border"></div>
    <ul>
        <a href="https://www.javatpoint.com/html-tutorial">HTML</a>
        <br>
            <a href="https://www.javatpoint.com/python-tutorial">PYTHON</a>
          <br>
            <a href="https://www.javatpoint.com/java-tutorial">java</a>
          <br>
          <a href="https://www.javatpoint.com/c-programming-language-tutorial">c language</a>
          <br>
          <a href="https://www.javatpoint.com/cpp-tutorial">C++</a>
          <br>
          <a href="https://www.javatpoint.com/c-sharp-tutorial">C#</a>
          
    </ul>
</div>
<div class="footer-items">
    <h3>Contact Us</h3>
    <div class="border"></div>
    <a href="https://www.facebook.com/javatpoint"><li><i class="fa fa-facebook" aria-hidden="true"></i></li>
    <img src="facebook.png"width="35px"height="35px"></a>
    <a href="https://www.javatpoint.com/instagram-algorithm"><li><i class="fa fa-instagram" aria-hidden="true"></i></li>
    <img src="instagram.webp"width="35px"height="35px"></a>
    <a href="https://twitter.com/pagejavatpoint"><li><i class="fa fa-twitter" aria-hidden="true"></i></li>
        <img src="twitter.png"width="35px"height="35px"></a>
        <a href="https://www.youtube.com/channel/UCUnYvQVCrJoFWZhKK3O2xLg"><li><i class="fa fa-youtube" aria-hidden="true"></i></li>
        <img src="youtube.png"width="35px"height="35px"></a>
    </div>
</div>

</div>
<div class="footer-bottom">
Copyright@codesyouth  2020. All rights reserved.
</div>

  
</footer>
     

</body>

</html>